# Importing necessary libraries
import random
from copy import deepcopy

# Initializing the game board
Board = [[0 for i in range(3)] for j in range(3)]
EmptySpace='-'  # To represent empty space in the board


# Function to initialize the board
def InitializeBoard():
    for i in range(3):
        for j in range(3):
            Board[i][j]=EmptySpace


# Function to display the current board state
def DisplayBoard():
    print()
    for i in range(3):
        print("-------------")
        for j in range(3):
            print("|", Board[i][j], end=" ")
        print("|")
    print("-------------")
    print()


# Function For Max move
def MaxMove():
    print('Max is making Move')
    MaxWinningMove = []
    MaxLoosingMove = []
    MaxNoEffect = []

    # Checking Moves Effect
    for i in range(3):
        for j in range(3):
            tempBoard = deepcopy(Board)
            tempBoard2 = deepcopy(Board)
            
            # Check if empty space available
            if (tempBoard[i][j]==EmptySpace):
                # Check for winning move 
                tempBoard[i][j] = 'X'
                if(MiniMax(tempBoard,'Max')==1):
                    MaxWinningMove.append((i,j))
                # Check for loosing move and block it 
                tempBoard2[i][j] = 'O'
                if(MiniMax(tempBoard2,'Max')==-1):
                    MaxLoosingMove.append((i,j))
                # Check for no effect move 
                if(MiniMax(tempBoard,'Max')==0 and (i,j) not in MaxLoosingMove and (i,j) not in MaxWinningMove):
                    MaxNoEffect.append((i,j))


    #Number of Successors Generated During Search
    print(f'Total Number of Successors Generated By Max Are : {len(MaxWinningMove)+len(MaxLoosingMove)+len(MaxNoEffect)}')
    print(MaxWinningMove)
    print(MaxLoosingMove)
    print(MaxNoEffect)

    # Making Suitable Move 
    if(len(MaxWinningMove)):
        # Make winning move
        x = MaxWinningMove.pop(0)
        Board[x[0]][x[1]] ='X'
    elif(len(MaxLoosingMove)):
        # Block loosing move
        x = MaxLoosingMove.pop(0)
        Board[x[0]][x[1]] ='X'
    elif((len(MaxNoEffect))):
        # Make any available move 
        x = random.choice(MaxNoEffect)
        Board[x[0]][x[1]] ='X'



# Function for Min move
def MinMove():
    print('Min is making Move')
    MinWinningMove = []
    MinLoosingMove = []
    MinNoEffect = []

    # Checking Moves Effect
    for i in range(3):
        for j in range(3):
            tempBoard = deepcopy(Board)
            tempBoard2 = deepcopy(Board)
            
            # Check if empty space available
            if (tempBoard[i][j]==EmptySpace):
                # Check for winning move 
                tempBoard[i][j] = 'O'
                if(MiniMax(tempBoard,'Min')==1):
                    MinWinningMove.append((i,j))
                # Check for loosing move and block it 
                tempBoard2[i][j] = 'X'
                if(MiniMax(tempBoard2,'Min')==-1):
                    MinLoosingMove.append((i,j))
                # Check for no effect move 
                if(MiniMax(tempBoard,'Min')==0 and (i,j) not in MinLoosingMove and (i,j) not in MinWinningMove):
                    MinNoEffect.append((i,j))


    #Number of Successors Generated During Search
    print(f'Total Number of Successors Generated By Min Are : {len(MinWinningMove)+len(MinLoosingMove)+len(MinNoEffect)}')
    print(MinWinningMove)
    print(MinLoosingMove)
    print(MinNoEffect)


    # Making Suitable Move 
    if(len(MinWinningMove)):
        # Make winning move
        x = MinWinningMove.pop(0)
        Board[x[0]][x[1]] ='O'
    elif(len(MinLoosingMove)):
        # Block loosing move
        x = MinLoosingMove.pop(0)
        Board[x[0]][x[1]] ='O'
    elif((len(MinNoEffect))):
        # Make any available move 
        x = random.choice(MinNoEffect)
        Board[x[0]][x[1]] ='O'



# Function to check Conditions for Max
def MiniMax(tempBoard,player):
    # Checking for Max's win or Min's Loosing condition
    for i in range(3):
        if(tempBoard[i][0]=='X' and tempBoard[i][1]=='X' and tempBoard[i][2]=='X') or (tempBoard[0][i]=='X' and tempBoard[1][i]=='X' and tempBoard[2][i]=='X'):
            if(player=='Min'):
                return -1
            else:
                return 1
            
    if((tempBoard[0][0]=='X' and tempBoard[1][1]=='X' and tempBoard[2][2]=='X') or (tempBoard[0][2]=='X' and tempBoard[1][1]=='X' and tempBoard[2][0]=='X')):
            if(player=='Min'):
                return -1
            else:
                return 1
    
    # Checking for Min's win or Max Loosing condition
    for i in range(3):
        if(tempBoard[i][0]=='O' and tempBoard[i][1]=='O' and tempBoard[i][2]=='O') or (tempBoard[0][i]=='O' and tempBoard[1][i]=='O' and tempBoard[2][i]=='O'):
            if(player=='Min'):
                return 1
            else:
                return -1
    if((tempBoard[0][0]=='O' and tempBoard[1][1]=='O' and tempBoard[2][2]=='O') or (tempBoard[0][2]=='O' and tempBoard[1][1]=='O' and tempBoard[2][0]=='O')):
            if(player=='Min'):
                return 1
            else:
                return -1    
    return 0


# Function to check for winning condition
def CheckWin():
    # Checking for Min's win condition
    for i in range(3):
        if(Board[i][0]=='O' and Board[i][1]=='O' and Board[i][2]=='O') or (Board[0][i]=='O' and Board[1][i]=='O' and Board[2][i]=='O'):
            print("Min Won!!")
            return 1
    if((Board[0][0]=='O' and Board[1][1]=='O' and Board[2][2]=='O') or (Board[0][2]=='O' and Board[1][1]=='O' and Board[2][0]=='O')):
        print("Min Won!!")
        return 1
    
    # Checking for Max's win condition
    for i in range(3):
        if(Board[i][0]=='X' and Board[i][1]=='X' and Board[i][2]=='X') or (Board[0][i]=='X' and Board[1][i]=='X' and Board[2][i]=='X'):
            print("Max Won!!")
            return 1
    if((Board[0][0]=='X' and Board[1][1]=='X' and Board[2][2]=='X') or (Board[0][2]=='X' and Board[1][1]=='X' and Board[2][0]=='X')):
        print("Max Won!!")
        return 1
    
    return 0


# Draw Game Check
def CheckDraw():
    for i in range(3):
        for j in range(3):
            if(Board[i][j]==EmptySpace):
                return False
    print('Game Draw!!')
    return 1


# Toss
def Toss():
    return random.randint(0,1)

# Game Play
def PlayGame():
    nexTurn=0
    MinMovesCount=0
    MaxMovesCount=0

    InitializeBoard()
    DisplayBoard()

    if(Toss()==0):
        print("Min Won The Toss")
        MinMove()
        MinMovesCount += 1
        nexTurn = 1
    else:
        print("Max Won The Toss")
        MaxMove()
        MaxMovesCount += 1
        nexTurn = 0

    while True:
        DisplayBoard()
        if(nexTurn == 1):
            MaxMove()
            MaxMovesCount += 1
            nexTurn = 0
            if(CheckWin()==1 or CheckDraw()==1):
                DisplayBoard()
                print(f'Number of Moves Min Made : {MinMovesCount}')
                print(f'Number of Moves Max Made : {MaxMovesCount}')
                break
            
        elif(nexTurn == 0):
            MinMove()
            MinMovesCount += 1
            nexTurn = 1
            if(CheckWin()==1 or CheckDraw()==1):
                DisplayBoard()
                print(f'Number of Moves Min Made : {MinMovesCount}')
                print(f'Number of Moves Max Made : {MaxMovesCount}')
                break

# Game Play Started From Here
PlayGame()